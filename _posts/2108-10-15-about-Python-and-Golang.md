---
layout: post
title:  "About Python and Golang"
categories: Python Golang
tags:  Python Golang
author: LWL
---

* content
{:toc}

## 目的：

记录下关于Python以及Golang的发展和趋势



## Python：

这一两年Python在业内大火，除了云计算帮Python带了一波节奏外，还有没有其它原因呢？必然有，我认为还有一个主要原因就是近几点互联网创业热情高涨，千千万万程序员听了各种创业鸡汤，辞掉了大公司安稳工作玩创业，13、14、15年的成都软件园D区灵感咖啡那叫一个热闹，基本每天都很多人在那里讨论创业项目，和投资人各种的吹牛逼，当时大家都急着要把东西快速开发出来去拿融资，那时的投资人脑子也是热呀，大批大批的钱投给各创业公司，供他们各种现金补贴抢用户。 时间就是金钱，大家恨不得今天刚有了idea，明天产品就能上线，产品晚上线一个月，可能战争就跟你没关系了。 因此，一门开发效率极高的语言就此进入开发者眼帘，开发者们因为犹如神助，开发效率不知道比C、Java高到那里去了，众多创业公司首选 Python做为开发语言，虽然那些创业公司大多都 失败了，但是催生起了Python在国内大热的前戏。从这里可以看出Python是开发效率较高的一门语言。

虽然Python的开发效率较高，但是早年的Python的运行速度相对于其他语言要慢一些也是被很多程序员诟病Python的主要原因，但最近几年PyPy解释器在不断的提高着Python的运行速度 ，通过PyPy运行的程序，在某些场景下速度直接逼近C语言，相信再过几年，Python的运行速度将不再是问题。另外，由于近些年CPU处理速度的快速发展，编程语言本身的快慢在大多数业务场景下已不再被做为主要考量（除了对响应速度极为敏感的业务，如搜索），因此，可以看出Python在追求运行速度快上也是有所考虑的。

最后一个就是Python的功能，由于环境机制和语言特性，让Python强大起来是分分钟的事情，只要会配置源，会配置环境，开发就会变得非常简单了，这是导致Python大火的另一个主要原因之一，Python的标准库和第三方库强大到你无法想象，无论你想从事任何方向的技术编程，你几乎都能找到相应的库支持，以下仅举几个例子：

WEB开发：最火的Python web框架Django，支持异步高并发的Tornado框架，短小精悍的flask、bottle、Django官方的标语把Django定义为the framework for perfectionist with deadlines（大意是一个为完全主义者开发的高效率web框架）。

网络编程：支持高并发的Twisted网络框架， py3引入的asyncio使异步编程变的非常简单。

爬虫：爬虫领域，Python几乎是霸主地位，Scrapy\Request\BeautifuSoap\urllib等，想爬啥就爬啥。

云计算：目前最火最知名的云计算框架就是OpenStack，Python现在的火，很大一部分就是因为云计算。

人工智能：谁会成为AI 和大数据时代的第一开发语言？这本已是一个不需要争论的问题。如果说五年前，Matlab、Scala、R、Java 和 Python还各有机会，局面尚且不清楚，那么五年之后，趋势已经非常明确了，特别是前段时间 Facebook 开源了 PyTorch 之后，Python 作为 AI 时代头牌语言的位置基本确立，未来的悬念仅仅是谁能坐稳第二把交椅。

自动化运维：问问中国的每个运维人员，运维人员必须会的语言是什么？10个人相信会给你一个相同的答案，它的名字叫Python。

金融分析：我有个朋友之前在金融行业，10年的时候，他们公司写的好多分析程序、高频交易软件就是用的Python。到目前，Python是金融分析、量化交易领域里用的最多的语言。

科学运算：你知道么？97年开始，NASA就在大量使用Python在进行各种复杂的科学运算，随着NumPy、SciPy、Matplotlib、Enthought librarys等众多程序库的开发，使的Python越来越适合于做科学计算、绘制高质量的2D和3D图像。和科学计算领域最流行的商业软件Matlab相比，Python是一门通用的程序设计语言，比Matlab所采用的脚本语言的应用范围更广泛。

游戏开发：在网络游戏开发中Python也有很多应用。相比Lua or C++，Python 比 Lua 有更高阶的抽象能力，可以用更少的代码描述游戏业务逻辑。与 Lua 相比，Python 更适合作为一种 Host 语言，即程序的入口点是在 Python 那一端会比较好，然后用 C/C++ 在非常必要的时候写一些扩展。Python 非常适合编写 1 万行以上的项目，而且能够很好地把网游项目的规模控制在 10 万行代码以内。另外据我所知，知名的游戏<文明>就是用Python写的。


## Golang：

概述
golang is a better C and a simple C++

golang主要特性
1、语法简单
舍弃语法糖，严格控制关键字
C++语法糖之多，令人发指，而C又太过于底层，容易出现自己造轮子的情况，如何在两者之间取舍，是每一个转向golang的工程师曾经思考过的问题。

golang的出现，就是在C和C++之间的刚刚好的取舍。

2、垃圾回收
golang支持垃圾回收，相比C/C++是一大进步。
c + +由于存在指针计算，即p++、p--等，无法提供垃圾回收功能，而golang虽然有指针，但是舍弃了指针的++、--等操作，所以提供了垃圾回收功能。

标记清除
3、错误处理
报告普通错误+报告致命错误
C语言中错误处理并不是语言规范的一部分，只是提供了errno这种系统相关的错误处理机制。而golang提供了语言层面上的错误处理的支持。

golang中可以有两种错误处理方式：一种对C的错误处理的规范化：每次函数调用都检查返回值，另一种类似C++和java中的try+catch+finally+throw。一般第一种用于报告普通的错误，第二种用于报告致命错误，如除0，访问数组越界。

error接口：实现error接口只需实现Error函数。golang支持多返回值，一般函数最后一个返回值是err error。

defer、panic和recover：异常处理机制，实现try+catch+finally+throw的功能，panic类似于throw关键字，即抛出异常，recover类似于catch，即捕获异常，defer类似于C中的atexit，java中的finally

个人认为golang的这种错误处理方式比C、C++、java都更加优雅，当然，这样会造成写10行代码，可能有5行都在处理错误的情况发生。

4、面向对象
在面向对象上，go语言表现得非常简洁和直接。

封装

封装这一块，可以细分为封装+隐藏：
①封装：将数据和基于数据的操作封装在一起，在C++中，通过隐藏的this指针传递对象的地址，在C中，要实现封装，要显式传递，在golang中，与C类似，显式传递，只不过换了个更加明显的位置。如：
②隐藏：C++和java都使用访问控制符实现隐藏特性，即隐藏内部实现细节，只保留一部分对外接口与外部发生联系。C用static关键字实现隐藏，而golang中，首字母大小写代表了是否对外开放访问，还是很机智的。

继承
继承关系一般有两种："is a"和"has a"
①"is a": 父：水果 子：苹果
②"has a": 父：羽毛 子：鸟
继承一般分为golang的设计哲学中反对继承，只提供最简单的组合，即"has a"关系。

多态
golang的面向对象中最重要的就是接口，golang中的接口与其他语言的最大的区别就是它的非侵入性。

①非侵入性接口：只要实现了接口要求的所有方法，就实现了该接口，可以进行赋值。
②侵入性接口： 类需要明确的申明自己实现了某个接口。

非侵入性接口的好处：
实现一个类的时候不用再考虑我需要实现哪些接口，即接口由使用方按需定义，而不用事前规划。
比如在实现第三方库的时候，由调用方抽象出所需接口，即可屏蔽太多不需要关注的内容，也便于日后替换。

另外：

golang反对函数和运算符重载，因为这些特性解决了小部分OOP的问题，但是却为语言本身带来极大的负担。
golang不支持构造函数和析构函数，构造函数用NewFunc之类的函数代替。
总的来说，golang对java这种激进的面向对象主义有限接收，时刻警惕语言特性复杂化。
虽然面向对象这块看起来太简洁，但是Cpp和java中能实现的面向对象的需求，golang中并不会出现不能表达的情况，这让人反思C++和java引入如此多复杂概念的必要性。

5、并发编程
不要通过共享内存来通信，而应该通过通信来共享内存
golang是为并发而生的语言，goroutine+channel使得并发编程变得容易。

并发模型：

多进程
多线程
事件驱动（reactor模型、epoll+回调、epoll+消息队列+线程池、异步非阻塞）：libevent、 muduo、 node js
goroutine：类似于协程，用户空间自己实现调度，但是协程一般采用N:1线程模型，而golang采用更加复杂的M:N模型，所以golang一般单独称自己为go程。
而channel，可以理解为：用于并发单元间的数据解耦的、阻塞的、带类型的、并发安全的消息队列。channel可分为带缓冲的和不带缓冲的。

当然，golang依然提供了各种同步互斥机制，与C和C++不同的是，golang对这些机制都做了封装：

管道 ①匿名管道 ②命名管道，基于文件的，有原子性问题 ③基于内存的，有原子性操作保证的管道

信号

socket

互斥锁

条件变量

读写锁

原子操作

6、代码规范
每个人写的代码都基本一致，不带个人色彩。
golang最符合我胃口的除了并发这一块，就是极其严格的代码规范要求了。作为有点儿代码洁癖的人，在遇到golang之前，每次看到别人的C/C++代码甚至是自己写的代码，都觉得很乱，而接触golang之后，一下就被其干净、严格的代码规范吸引。

另一方面，相信每一个团队都会对代码规范做出要求，但是培训成本通常会很高，团队成员会不会严格遵守也不好说，所以反正都是要做的事，为何不在语言层面就做了呢？

7、部署发布
将运行时、依赖库直接打包到可执行文件内部，简化部署和发布
golang采用静态链接的方式编译，在部署的时候很方便，只需要配置文件和可执行文件。而C/C++得部署一般需要很多动态链接库，一个so的版本不对从而导致查bug查几天的事情时常发生，所以出现docker简化部署的问题。

用docker更好还是用golang的静态链接更好，见仁见智，不过，docker也是golang写的，所以，这个特性golang胜利。

8、强大的官方package和工具链
官方package本身非常强大，基本解决了程序员开发过程中的大部分需求，而一些特定的领域也能在开源社区中找到不错的组件，不像C系，一些很基本的库也要到处去找，各个版本区别也很大。

网络：net、http、rpc、json
安全：加解密
容器
数据库连接
io
单元测试和性能测试
其他特性
可执行文件直接支持GDB调试，也可以直接objdump查看反汇编
支持函数式编程，即匿名函数和闭包：函数是第一级对象，可以作为参数和返回值。
函数多返回值
反射
更丰富的内置类型：其他语言中的作为库出现的string、map、slice等直接弄成内置类型，又少了几行include代码，你说机智不机智。
强制要求显式类型转换： 隐式类型转换造成的问题远大于带来的好处，所以go强制要求使用显式类型转换，加上不支持操作符重载，所以我们总是能够确定语句和表达式的明确含义。
golang也有一些发展不成熟的地方：

官方库依然不够完整：比如容器方面，只有map（golang的map是hashmap），没有红黑树的实现的有序map，没有concurrent map，没有set和hashset等，要想干掉java，路还很长
生态依然不够成熟：没有java的各种强大的中间件，不过随着使用golang的团队的增加，这个问题会解决的
总之，道阻且长，行则将至。










